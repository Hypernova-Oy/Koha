.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::MarcOrder 3pm"
.TH Koha::MarcOrder 3pm "2025-09-02" "perl v5.32.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::MarcOrder \- Koha Marc Order Object class
.SH "API"
.IX Header "API"
.SS "Class methods"
.IX Subsection "Class methods"
\fIcreate_order_lines_from_file\fR
.IX Subsection "create_order_lines_from_file"
.PP
.Vb 1
\&    my $result = Koha::MarcOrder\->create_order_lines_from_file($args);
\&
\&    Controller for file staging, basket creation and order line creation when using the cronjob in marc_ordering_process.pl
.Ve
.PP
\fIimport_record_and_create_order_lines\fR
.IX Subsection "import_record_and_create_order_lines"
.PP
.Vb 1
\&    my $result = Koha::MarcOrder\->import_record_and_create_order_lines($args);
\&
\&    Controller for record import and order line creation when using the interface in addorderiso2709.pl
.Ve
.PP
\fI_create_basket_for_file\fR
.IX Subsection "_create_basket_for_file"
.PP
.Vb 4
\&    my $basket_id = _create_basket_for_file({
\&        filename  => $filename,
\&        vendor_id => $vendor_id
\&    });
\&
\&    Creates a basket ready to receive order lines based on the imported file
.Ve
.PP
\fI_stage_file\fR
.IX Subsection "_stage_file"
.PP
.Vb 1
\&    $file\->_stage_file($params)
\&
\&    Stages a file directly using parameters from a MARC ordering account
.Ve
.PP
\fI_get_syspref_mappings\fR
.IX Subsection "_get_syspref_mappings"
.PP
.Vb 1
\&    my $syspref_info = _get_syspref_mappings( $marcrecord, $syspref_name );
\&
\&    Fetches data from a MARC record based on the mappings in the syspref MarcFieldsToOrder or MarcItemFieldsToOrder using the fields selected in $fields (array).
.Ve
.PP
\fI_verify_number_of_fields\fR
.IX Subsection "_verify_number_of_fields"
.PP
.Vb 1
\&    my $tags_count = _verify_number_of_fields(\e@tags_list, $record);
\&
\&    Verifies that the number of fields in the record is consistent for each field
.Ve
.PP
\fIadd_biblio_from_import_record\fR
.IX Subsection "add_biblio_from_import_record"
.PP
.Vb 8
\&    my ($record_results, $duplicates_in_batch) = add_biblio_from_import_record({
\&        import_record             => $import_record,
\&        matcher_id                => $matcher_id,
\&        overlay_action            => $overlay_action,
\&        import_record_id_selected => $import_record_id_selected,
\&        agent                     => $agent,
\&        import_batch_id           => $import_batch_id
\&    });
\&
\&    Takes a set of import records and adds biblio records based on the file content.
\&    Params matcher_id and overlay_action are taken from the MARC ordering account.
\&    Returns the new or matched biblionumber and the MARC record for each import record.
.Ve
.PP
\fIadd_items_from_import_record\fR
.IX Subsection "add_items_from_import_record"
.PP
.Vb 8
\&    my $order_line_details = add_items_from_import_record({
\&        record_result      => $record_result,
\&        basket_id          => $basket_id,
\&        vendor             => $vendor,
\&        budget_id          => $budget_id,
\&        agent              => $agent,
\&        client_item_fields => $client_item_fields
\&    });
\&
\&    Adds items to biblio records based on mappings in MarcItemFieldsToOrder.
\&    Returns an array of order line details based on newly added items.
\&    If being called from addorderiso2709.pl then client_item_fields is a hash of all the UI form inputs needed by the script.
.Ve
.PP
\fImatch_file_to_account\fR
.IX Subsection "match_file_to_account"
.PP
.Vb 5
\&    my $file_match = Koha::MarcOrder\->match_file_to_account({
\&        filename => $filename,
\&        filepath => $filepath,
\&        profile  => $profile
\&    });
\&
\&    Used by the cronjob to detect whether a file matches the account and should be processed
\&    This method only checks the first record in the file.
.Ve
.PP
\fIimport_batches_list\fR
.IX Subsection "import_batches_list"
.PP
Fetches import batches matching the batch to be added to the basket and returns these to the template
.PP
Koha::MarcOrder\->\fBimport_batches_list()\fR;
.PP
\fIimport_biblios_list\fR
.IX Subsection "import_biblios_list"
.PP
For an import batch, this function reads the files and creates all the relevant data pertaining to that file
It then returns this to the template to be shown in the \s-1UI\s0
.PP
Koha::MarcOrder\->import_biblios_list( \f(CW$cgiparams\fR\->{'import_batch_id'} );
.PP
\fIparse_input_into_order_line_fields\fR
.IX Subsection "parse_input_into_order_line_fields"
.PP
This function takes inputs from either the cronjob or \s-1UI\s0 and then parses that into a single set of order line fields that can be used to create items and order lines
.PP
my \f(CW$order_line_fields\fR = parse_input_into_order_line_fields(
    {
        agent        => \f(CW$agent\fR,
        biblionumber => \f(CW$biblionumber\fR,
        budget_id    => \f(CW$budget_id\fR,
        basket_id    => \f(CW$basket_id\fR,
        fields       => \f(CW$item_fields\fR,
        marcrecord   => \f(CW$marcrecord\fR,
    }
);
.PP
\fIcreate_items_and_generate_order_hash\fR
.IX Subsection "create_items_and_generate_order_hash"
.PP
This method is used from both the cronjob and the \s-1UI\s0 to create items and generate order line details for those new items
.PP
my \f(CW$order_line_details\fR = create_items_and_generate_order_hash(
    {
        fields          => \f(CW$order_line_fields\fR,
        vendor          => \f(CW$vendor\fR,
        agent           => \f(CW$agent\fR,
        active_currency => \f(CW$active_currency\fR,
    }
);
.PP
\fI_format_price_to_CurrencyFormat_syspref\fR
.IX Subsection "_format_price_to_CurrencyFormat_syspref"
.PP
In France, the cents separator is the ',' but sometimes a '.' is used
In this case, the price will be x100 when unformatted
The '.' needs replacing by a ',' to get a proper price calculation
.PP
\fI_create_item_fields_from_syspref\fR
.IX Subsection "_create_item_fields_from_syspref"
.PP
Takes the two sysprefs and returns the item fields required to process and create orderlines
.PP
my \f(CW$item_fields\fR = _create_item_fields_from_syspref(
    {
        marc_fields_to_order      => \f(CW$marc_fields_to_order\fR,
        marc_item_fields_to_order => \f(CW$marc_item_fields_to_order\fR
    }
);
